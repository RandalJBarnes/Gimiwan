//=============================================================================
// test_engine.cpp
//
// author:
//    Dr. Randal J. Barnes
//    Department of Civil, Environmental, and Geo- Engineering
//    University of Minnesota
//
// version:
//    30 June 2017
//=============================================================================
#include <utility>

#include "test_engine.h"
#include "unit_test.h"
#include "..\src\engine.h"
#include "..\src\numerical_constants.h"

//-----------------------------------------------------------------------------
// Hide all of the testing details inside an unnamed namespace. This allows me
// to create many small unit tests with polluting the global namespace.
//-----------------------------------------------------------------------------
namespace{
   const double TOLERANCE = 1e-9;

   //--------------------------------------------------------------------------
   // TestSetupQuadraticModel
   //
   //    This is simply an example problem.  The "correct" solution was
   //    computed using parallel Matlab code.
   //--------------------------------------------------------------------------
   bool TestSetupQuadraticModel()
   {
      double xo = 2250;
      double yo = -2250;

      double conductivity = 10;
      double thickness = 10;

      std::vector<ObsRecord> obs = {
         ObsRecord{"01",1000,-1000,100,1},
         ObsRecord{"02",1000,-1500,105,1},
         ObsRecord{"03",1000,-2000,110,1},
         ObsRecord{"04",1000,-2500,115,1},
         ObsRecord{"05",1000,-3000,120,1},
         ObsRecord{"06",1500,-1000,95,1},
         ObsRecord{"07",1500,-1500,100,1},
         ObsRecord{"08",1500,-2000,105,1},
         ObsRecord{"09",1500,-2500,110,1},
         ObsRecord{"10",1500,-3000,115,1},
         ObsRecord{"11",2000,-1000,90,1},
         ObsRecord{"12",2000,-1500,95,1},
         ObsRecord{"13",2000,-2000,100,1},
         ObsRecord{"14",2000,-2500,105,1},
         ObsRecord{"15",2000,-3000,110,1},
         ObsRecord{"16",2500,-1000,85,1},
         ObsRecord{"17",2500,-1500,90,1},
         ObsRecord{"18",2500,-2000,95,1},
         ObsRecord{"19",2500,-2500,100,1},
         ObsRecord{"20",2500,-3000,105,1},
         ObsRecord{"21",3000,-1000,80,1},
         ObsRecord{"22",3000,-1500,85,1},
         ObsRecord{"23",3000,-2000,90,1},
         ObsRecord{"24",3000,-2500,95,1},
         ObsRecord{"25",3000,-3000,100,1}
      };

      std::vector<WellRecord> wells = {
         WellRecord{"12345",2250,-2250,0.25,750}
      };

      Matrix X, Vinv, Y;
      std::tie(X, Vinv, Y) = SetupQuadraticModel(xo, yo, conductivity, thickness, obs, wells);

      static const double X_data[] = {
        1562500.0,     1562500.0,    -1562500.0,       -1250.0,        1250.0,           1.0,
        1562500.0,      562500.0,     -937500.0,       -1250.0,         750.0,           1.0,
        1562500.0,       62500.0,     -312500.0,       -1250.0,         250.0,           1.0,
        1562500.0,       62500.0,      312500.0,       -1250.0,        -250.0,           1.0,
        1562500.0,      562500.0,      937500.0,       -1250.0,        -750.0,           1.0,
         562500.0,     1562500.0,     -937500.0,        -750.0,        1250.0,           1.0,
         562500.0,      562500.0,     -562500.0,        -750.0,         750.0,           1.0,
         562500.0,       62500.0,     -187500.0,        -750.0,         250.0,           1.0,
         562500.0,       62500.0,      187500.0,        -750.0,        -250.0,           1.0,
         562500.0,      562500.0,      562500.0,        -750.0,        -750.0,           1.0,
          62500.0,     1562500.0,     -312500.0,        -250.0,        1250.0,           1.0,
          62500.0,      562500.0,     -187500.0,        -250.0,         750.0,           1.0,
          62500.0,       62500.0,      -62500.0,        -250.0,         250.0,           1.0,
          62500.0,       62500.0,       62500.0,        -250.0,        -250.0,           1.0,
          62500.0,      562500.0,      187500.0,        -250.0,        -750.0,           1.0,
          62500.0,     1562500.0,      312500.0,         250.0,        1250.0,           1.0,
          62500.0,      562500.0,      187500.0,         250.0,         750.0,           1.0,
          62500.0,       62500.0,       62500.0,         250.0,         250.0,           1.0,
          62500.0,       62500.0,      -62500.0,         250.0,        -250.0,           1.0,
          62500.0,      562500.0,     -187500.0,         250.0,        -750.0,           1.0,
         562500.0,     1562500.0,      937500.0,         750.0,        1250.0,           1.0,
         562500.0,      562500.0,      562500.0,         750.0,         750.0,           1.0,
         562500.0,       62500.0,      187500.0,         750.0,         250.0,           1.0,
         562500.0,       62500.0,     -187500.0,         750.0,        -250.0,           1.0,
         562500.0,      562500.0,     -562500.0,         750.0,        -750.0,           1.0
      };
      Matrix X_true(25, 6, X_data);

      static const double Y_data[] = {
          8607.44247682397,
          9130.46001064384,
          9646.47083796387,
          10146.4708379639,
          10630.4600106438,
          8130.46001064384,
          8668.41779413424,
          9203.49872658524,
          9703.49872658524,
          10168.4177941342,
          7646.47083796387,
          8203.49872658524,
          8799.55497634651,
          9299.55497634651,
          9703.49872658524,
          7146.47083796387,
          7703.49872658524,
          8299.55497634651,
          8799.55497634651,
          9203.49872658524,
          6630.46001064384,
          7168.41779413424,
          7703.49872658524,
          8203.49872658524,
          8668.41779413424
      };
      Matrix Y_true(25, 1, Y_data);

      Matrix Eye, Vinv_true;
      Identity(Eye, 25);
      Multiply_aM(0.0001, Eye, Vinv_true);

      bool flag = true;
      flag &= CHECK( isClose(X, X_true, TOLERANCE) );
      flag &= CHECK( isClose(Y, Y_true, TOLERANCE) );
      flag &= CHECK( isClose(Vinv, Vinv_true, TOLERANCE) );
      return flag;
   }

   //--------------------------------------------------------------------------
   // TestFitQuadraticModel
   //
   //    This is simply an example problem.  The "correct" solution was
   //    computed using parallel Matlab code.
   //--------------------------------------------------------------------------
   bool TestFitQuadraticModel() {

      static const double X_data[] = {
        1562500.0,     1562500.0,    -1562500.0,       -1250.0,        1250.0,           1.0,
        1562500.0,      562500.0,     -937500.0,       -1250.0,         750.0,           1.0,
        1562500.0,       62500.0,     -312500.0,       -1250.0,         250.0,           1.0,
        1562500.0,       62500.0,      312500.0,       -1250.0,        -250.0,           1.0,
        1562500.0,      562500.0,      937500.0,       -1250.0,        -750.0,           1.0,
         562500.0,     1562500.0,     -937500.0,        -750.0,        1250.0,           1.0,
         562500.0,      562500.0,     -562500.0,        -750.0,         750.0,           1.0,
         562500.0,       62500.0,     -187500.0,        -750.0,         250.0,           1.0,
         562500.0,       62500.0,      187500.0,        -750.0,        -250.0,           1.0,
         562500.0,      562500.0,      562500.0,        -750.0,        -750.0,           1.0,
          62500.0,     1562500.0,     -312500.0,        -250.0,        1250.0,           1.0,
          62500.0,      562500.0,     -187500.0,        -250.0,         750.0,           1.0,
          62500.0,       62500.0,      -62500.0,        -250.0,         250.0,           1.0,
          62500.0,       62500.0,       62500.0,        -250.0,        -250.0,           1.0,
          62500.0,      562500.0,      187500.0,        -250.0,        -750.0,           1.0,
          62500.0,     1562500.0,      312500.0,         250.0,        1250.0,           1.0,
          62500.0,      562500.0,      187500.0,         250.0,         750.0,           1.0,
          62500.0,       62500.0,       62500.0,         250.0,         250.0,           1.0,
          62500.0,       62500.0,      -62500.0,         250.0,        -250.0,           1.0,
          62500.0,      562500.0,     -187500.0,         250.0,        -750.0,           1.0,
         562500.0,     1562500.0,      937500.0,         750.0,        1250.0,           1.0,
         562500.0,      562500.0,      562500.0,         750.0,         750.0,           1.0,
         562500.0,       62500.0,      187500.0,         750.0,         250.0,           1.0,
         562500.0,       62500.0,     -187500.0,         750.0,        -250.0,           1.0,
         562500.0,      562500.0,     -562500.0,         750.0,        -750.0,           1.0
      };
      Matrix X(25, 6, X_data);

      static const double Y_data[] = {
          8607.44247682397,
          9130.46001064384,
          9646.47083796387,
          10146.4708379639,
          10630.4600106438,
          8130.46001064384,
          8668.41779413424,
          9203.49872658524,
          9703.49872658524,
          10168.4177941342,
          7646.47083796387,
          8203.49872658524,
          8799.55497634651,
          9299.55497634651,
          9703.49872658524,
          7146.47083796387,
          7703.49872658524,
          8299.55497634651,
          8799.55497634651,
          9203.49872658524,
          6630.46001064384,
          7168.41779413424,
          7703.49872658524,
          8203.49872658524,
          8668.41779413424
      };
      Matrix Y(25, 1, Y_data);

      Matrix Eye, Vinv;
      Identity(Eye, 25);
      Multiply_aM(0.0001, Eye, Vinv);

      std::vector<int> is_active(25);
      std::fill(is_active.begin(), is_active.end(), 1);

      Matrix P_ev, P_cov;
      std::tie(P_ev, P_cov) = FitQuadraticModel(X, Vinv, Y);

      static const double P_ev_data[] = {
        -7.20476189326098e-05,
        -7.20476189326105e-05,
        -7.88066946065188e-06,
            -1.00588312418789,
           -0.994116875812116,
             8766.22133799834
      };
      Matrix P_ev_true(6, 1, P_ev_data);

      static const double P_cov_data[] = {
         2.28571428571429e-09,      5.16987882845642e-25,      2.58493941422821e-26,      1.14285714285714e-06,     -2.38228016415272e-22,                    -0.001,
         5.16987882845642e-25,      2.28571428571429e-09,     -5.16987882845642e-26,      3.70576914423756e-22,     -1.14285714285714e-06,                    -0.001,
         2.58493941422821e-26,     -5.16987882845642e-26,                   1.6e-09,                    -4e-07,                     4e-07,     -9.99999999999999e-05,
         1.14285714285714e-06,      3.70576914423756e-22,                    -4e-07,       0.00147142857142857,                   -0.0001,                    -0.275,
        -2.38228016415272e-22,     -1.14285714285714e-06,                     4e-07,                   -0.0001,       0.00147142857142857,                     0.275,
                       -0.001,                    -0.001,     -9.99999999999999e-05,                    -0.275,                     0.275,                   1381.25
      };
      Matrix P_cov_true(6, 6, P_cov_data);

      bool flag = true;
      flag &= CHECK( isClose(P_ev,  P_ev_true,  TOLERANCE) );
      flag &= CHECK( isClose(P_cov, P_cov_true, TOLERANCE) );
      return flag;
   }

   //--------------------------------------------------------------------------
   // TestComputeGeohydrologyStatistics
   //
   //    This is simply an example problem.  The "correct" solution was
   //    computed using parallel Matlab code.
   //--------------------------------------------------------------------------
   bool TestComputeGeohydrologyStatistics() {

      static const double P_ev_data[] = {
        -7.20476189326098e-05,
        -7.20476189326105e-05,
        -7.88066946065188e-06,
            -1.00588312418789,
           -0.994116875812116,
             8766.22133799834
      };
      Matrix P_ev_true(6, 1, P_ev_data);

      static const double P_cov_data[] = {
         2.28571428571429e-09,      5.16987882845642e-25,      2.58493941422821e-26,      1.14285714285714e-06,     -2.38228016415272e-22,                    -0.001,
         5.16987882845642e-25,      2.28571428571429e-09,     -5.16987882845642e-26,      3.70576914423756e-22,     -1.14285714285714e-06,                    -0.001,
         2.58493941422821e-26,     -5.16987882845642e-26,                   1.6e-09,                    -4e-07,                     4e-07,     -9.99999999999999e-05,
         1.14285714285714e-06,      3.70576914423756e-22,                    -4e-07,       0.00147142857142857,                   -0.0001,                    -0.275,
        -2.38228016415272e-22,     -1.14285714285714e-06,                     4e-07,                   -0.0001,       0.00147142857142857,                     0.275,
                       -0.001,                    -0.001,     -9.99999999999999e-05,                    -0.275,                     0.275,                   1381.25
      };
      Matrix P_cov_true(6, 6, P_cov_data);

      double R_ev_true = 0.000288190475730441;
      double R_sd_true = 0.000135224680756563;

      double M_ev_true = 1.41479360777816;
      double M_sd_true = 0.0370328974483369;

      double D_ev_true = 0.779515695353749;
      double D_sd_true = 0.0280300487210578;

      double R_ev, R_sd, M_ev, M_sd, D_ev, D_sd;
      std::tie(R_ev, R_sd, M_ev, M_sd, D_ev, D_sd) = ComputeGeohydrologyStatistics(P_ev_true, P_cov_true);

      bool flag = true;
      flag &= CHECK( isClose(R_ev, R_ev_true, TOLERANCE) );
      flag &= CHECK( isClose(R_sd, R_sd_true, TOLERANCE) );
      flag &= CHECK( isClose(M_ev, M_ev_true, TOLERANCE) );
      flag &= CHECK( isClose(M_sd, M_sd_true, TOLERANCE) );
      flag &= CHECK( isClose(D_ev, D_ev_true, TOLERANCE) );
      flag &= CHECK( isClose(D_sd, D_sd_true, TOLERANCE) );
      return flag;
   }
}

   //--------------------------------------------------------------------------
   bool TestEngine() {
      double xo = 2250.0;
      double yo = -2250.0;

      double k_alpha = 2.0;
      double k_beta  = 0.5;
      int    k_count = 3;

      double h_alpha = 2.0;
      double h_beta  = 0.1;
      int    h_count = 3;

      double radius  = 100;

      std::vector<ObsRecord> obs = {
         ObsRecord{"01",1000,-1000,100,1},
         ObsRecord{"02",1000,-1500,105,1},
         ObsRecord{"03",1000,-2000,110,1},
         ObsRecord{"04",1000,-2500,115,1},
         ObsRecord{"05",1000,-3000,120,1},
         ObsRecord{"06",1500,-1000,95,1},
         ObsRecord{"07",1500,-1500,100,1},
         ObsRecord{"08",1500,-2000,105,1},
         ObsRecord{"09",1500,-2500,110,1},
         ObsRecord{"10",1500,-3000,115,1},
         ObsRecord{"11",2000,-1000,90,1},
         ObsRecord{"12",2000,-1500,95,1},
         ObsRecord{"13",2000,-2000,100,1},
         ObsRecord{"14",2000,-2500,105,1},
         ObsRecord{"15",2000,-3000,110,1},
         ObsRecord{"16",2500,-1000,85,1},
         ObsRecord{"17",2500,-1500,90,1},
         ObsRecord{"18",2500,-2000,95,1},
         ObsRecord{"19",2500,-2500,100,1},
         ObsRecord{"20",2500,-3000,105,1},
         ObsRecord{"21",3000,-1000,80,1},
         ObsRecord{"22",3000,-1500,85,1},
         ObsRecord{"23",3000,-2000,90,1},
         ObsRecord{"24",3000,-2500,95,1},
         ObsRecord{"25",3000,-3000,100,1}
      };

      std::vector<WellRecord> wells = {
         WellRecord{"12345",2250,-2250,0.25,750}
      };

      Results results;
      results = Engine(xo, yo, k_alpha, k_beta, k_count, h_alpha, h_beta, h_count, radius, obs, wells);

      std::vector<double> k_true {4.555290100048275725, 7.389056098930650407, 11.98565817631804009};
      std::vector<double> h_true {6.707711558370498039,7.389056098930650407,8.139609098875407511};

      static const double R_ev_data[] = {
         0.0002881904757304113536,0.0002881904757303977468,0.0002881904757304182382,
         0.0002881904757304138472,0.0002881904757304025715,0.0002881904757304297308,
         0.0002881904757303529151,0.000288190475730404252,0.0002881904757305247611
      };
      Matrix R_ev_true(3, 3, R_ev_data);

      static const double R_sd_data[] = {
         4.13186747658301519e-005,4.551567298644503483e-005,5.013898676930082576e-005,
         6.702229694985912113e-005,7.383017408130831776e-005,8.132957020190223528e-005,
         0.0001087156912435608498,0.0001197586292198651094,0.0001319232680082011529
      };
      Matrix R_sd_true(3, 3, R_sd_data);

      static const double M_ev_data[] = {
         0.4323708549893038877,0.4762739766631226002,0.5246380449909110455,
         0.7012606794083517947,0.7724825830032123752,0.8509398260015376136,
         1.137453009115591884,1.252985384350457698,1.380253654772955807
      };
      Matrix M_ev_true(3, 3, M_ev_data);

      static const double M_sd_data[] = {
         0.01131589086175638185,0.01246525798656599772,0.01373137902967830684,
         0.01835500048726555408,0.02021939704323883272,0.02227317547543973889,
         0.02977313446803655367,0.03279735686562526564,0.03612877067000193343
      };
      Matrix M_sd_true(3, 3, M_sd_data);


      static const double D_ev_data[] = {
         43.89708214499925987,43.9987604046996168,44.09106839369568576,
         44.32000849194515268,44.38270538239297736,44.43962227912987828,
         44.58077883328078173,44.61943400444664576,44.65452508481450167
      };
      Matrix D_ev_true(3, 3, D_ev_data);

      Matrix D_ev_deg;
      Multiply_aM(RAD_TO_DEG, results.D_ev, D_ev_deg);

      static const double D_sd_data[] = {
         1.605699349749284632,1.605758349955243469,1.605806975813463211,
         1.605907296897844283,1.60592972843050541,1.605948214564432819,
         1.605986350483248781,1.605994876979402575,1.606001903618260895
      };
      Matrix D_sd_true(3, 3, D_sd_data);

      Matrix D_sd_deg;
      Multiply_aM(RAD_TO_DEG, results.D_sd, D_sd_deg);

      bool flag = true;
      flag &= CHECK( isClose(results.R_ev, R_ev_true, TOLERANCE) );
      flag &= CHECK( isClose(results.R_sd, R_sd_true, TOLERANCE) );
      flag &= CHECK( isClose(results.M_ev, M_ev_true, TOLERANCE) );
      flag &= CHECK( isClose(results.M_sd, M_sd_true, TOLERANCE) );
      flag &= CHECK( isClose(D_ev_deg, D_ev_true, TOLERANCE) );
      flag &= CHECK( isClose(D_sd_deg, D_sd_true, TOLERANCE) );
      return flag;
   }


//-----------------------------------------------------------------------------
// test_Engine
//-----------------------------------------------------------------------------
std::pair<int,int> test_Engine()
{
   int nsucc = 0;
   int nfail = 0;

   TALLY( TestSetupQuadraticModel() );
   TALLY( TestFitQuadraticModel() );
   TALLY( TestComputeGeohydrologyStatistics() );
   TALLY( TestEngine() );

   return std::make_pair( nsucc, nfail );
}
